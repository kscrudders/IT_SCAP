function [corrected, median_RICM, IRM_thres, IRM_LUT] = KLS_RICM_bkgd_correction(img,sig)
    bkgd = img;
    rows = round(size(bkgd,1)/512);
    cols = round(size(bkgd,2)/512);
    time = size(bkgd,3);
    
    if nargin < 2
        sig = [5 5];
    end
    
    if isempty(sig)
        sig = [5 5];
    end
    % You don't need to use all the data to generate
    % this data correction. This if/else reduces the 
    % data need to be processed.
    if time <3
         % do nothing
    else
        time = round(time*.1);
        if time < 3
             time = 3;
        end
        if time > 50
            time = 50;
        end
    end

    FOV = zeros(512,512,rows*cols*time);
    z = 1;
    for i = 1:time
        for ii = 1:rows
            for iii = 1:cols
                % these idx are long and convoluted becuase
                % they do some different specifically for the
                % first frame.
                x = ((1*(ii<2))+(512*((ii-1)*(ii>1))))+(1*(ii>1)):((512*(ii<2))+(512*((ii)*(ii>1))));
                y = ((1*(iii<2))+(512*((iii-1)*(iii>1))))+(1*(iii>1)):((512*(iii<2))+(512*((iii)*(iii>1))));
                FOV(:,:,z) = bkgd(x,y,i);
                z = z+1;
            end
        end
    end

    med_FOV = median(FOV,3);
    large_FOV = repmat(med_FOV,[rows cols size(img,3)]);
    
    median_RICM = med_FOV;
    corrected = (img-large_FOV)+round(mean(median_RICM,'all'));
    
    
    time = size(img,3);
    FOV = zeros(512,512,rows*cols*time);
    z = 1;
    for i = 1:time
        for ii = 1:rows
            for iii = 1:cols
                % these idx are long and convoluted becuase
                % they do something different specifically for the
                % first frame.
                x = ((1*(ii<2))+(512*((ii-1)*(ii>1))))+(1*(ii>1)):((512*(ii<2))+(512*((ii)*(ii>1))));
                y = ((1*(iii<2))+(512*((iii-1)*(iii>1))))+(1*(iii>1)):((512*(iii<2))+(512*((iii)*(iii>1))));
                FOV(:,:,z) = corrected(x,y,i);
                z = z+1;
            end
        end
    end
    
    h = histogram(corrected,'Normalization','pdf');
    Y = h.BinCounts;
    temp = movmean(h.BinEdges,2);
    X = temp(2:end);
    %sig = 5; % # sigma to set threshold for RICM close contacts
    [fitresult, ~, upper_thres] = LF_RICMFit_1guass(X, Y, sig);
    
    IRM_LUT = [min(corrected,[],'all') upper_thres+(fitresult.c1*sig(2))];
    
    IRM_thres = fitresult.b1-(fitresult.c1*sig(1));
    xline(IRM_thres,'--','LineWidth',3)
    
    %close all
    
    function [fitresult, lower_thres, upper_thres] = LF_RICMFit_1guass(X, Y, sig)
        %CREATEFIT(X,Y)
        %  Create a fit.
        %
        %  Data for 'untitled fit 1' fit:
        %      X Input : X
        %      Y Output: Y
        %  Output:
        %      fitresult : a fit object representing the fit.
        %      gof : structure with goodness-of fit info.

        %  Auto-generated by MATLAB on 28-Jul-2022 12:19:06
        [xData, yData] = prepareCurveData( X, Y );

        % Set up fittype and options.
        ft = fittype( 'gauss1' );
        opts = fitoptions( 'Method', 'NonlinearLeastSquares' );
        opts.Display = 'Off';
        opts.Lower = [0 min(X,[],'all') 0];
        opts.Upper = [inf max(X,[],'all') inf];
        
        max_y = max(Y,[],'all');
        idx_max_y = Y == max_y;
        amplitude_start = max_y;
        peak_centroid_in_x = X(idx_max_y);
        gaussian_width = 250;
        
        opts.StartPoint = [amplitude_start peak_centroid_in_x gaussian_width];

        % Fit model to data.
        [fitresult, ~] = fit( xData, yData, ft, opts );

        % Plot fit with data.
        figure( 'Name', 'Guassian Fit of RICM Data' );
        h1 = plot( fitresult, xData, yData );
        legend( h1, 'Counts (#) vs. IRM Inetensity', 'Single Guassian Fit', 'Location', 'Best', 'Interpreter', 'none' );
        % Label axes
        xlabel('Intensity (A.U.)');
        ylabel('Counts (#)');

        lower_thres = round(fitresult.b1 - (sig(1)*fitresult.c1));
        upper_thres = round(fitresult.b1 + (sig(2)*fitresult.c1));

        xline(lower_thres)
        xline(upper_thres)
    end
end